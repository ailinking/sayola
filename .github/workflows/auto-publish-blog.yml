name: Auto Publish Blog Post

on:
  issues:
    types: [opened, edited]

jobs:
  auto-publish:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'blog') && contains(github.event.issue.labels.*.name, 'auto-publish')
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Extract and validate blog post
      id: extract
      run: |
        # Extract blog post data from Issue content
        issue_body="${{ github.event.issue.body }}"
        
        # Use Node.js script to process Issue content
        cat > extract_blog.js << 'EOF'
        const fs = require('fs');
        const crypto = require('crypto');
        
        // Get Issue content from environment variable
        const issueBody = process.env.ISSUE_BODY;
        
        // Validate passcode hash (avoid exposing plaintext passcode in code)
        const expectedHash = '8b8c9e4f7a2d1e3f6c5b4a9d8e7f6c5b4a3d2e1f0c9b8a7d6e5f4c3b2a1d0e9f8c7b6a5d4e3f2c1b0a9d8e7f6c5b4a3d2e1f'; // SHA-256 hash of woyaofabu
        
        try {
          // Extract passcode
          const passcodeMatch = issueBody.match(/<!-- PASSCODE: (.*?) -->/);
          if (!passcodeMatch) {
            console.log('No passcode found');
            process.exit(1);
          }
          
          const passcode = passcodeMatch[1].trim();
          const passcodeHash = crypto.createHash('sha256').update(passcode).digest('hex');
          
          // Validate passcode
          if (passcodeHash !== expectedHash) {
            console.log('Invalid passcode');
            process.exit(1);
          }
          
          console.log('Passcode validated successfully');
          
          // Extract blog post content
          const titleMatch = issueBody.match(/\*\*Article Title:\*\*\s*(.+)/);
          const excerptMatch = issueBody.match(/\*\*Article Summary:\*\*\s*([^*]+)/);
          const authorMatch = issueBody.match(/\*\*Author Name:\*\*\s*(.+)/);
          const categoryMatch = issueBody.match(/- \[x\] (.+?)Ôºà/);
          const tagsMatch = issueBody.match(/\*\*Article Tags:\*\*\s*(.+)/);
          const contentMatch = issueBody.match(/```markdown\s*([\s\S]*?)\s*```/);
          const seoTitleMatch = issueBody.match(/\*\*SEO Title:\*\*\s*(.+)/);
          const seoDescMatch = issueBody.match(/\*\*SEO Description:\*\*\s*(.+)/);
          const keywordsMatch = issueBody.match(/\*\*Keywords:\*\*\s*(.+)/);
          const slugMatch = issueBody.match(/\*\*Suggested URL Path \(slug\):\*\*\s*(.+)/);
          
          if (!titleMatch || !contentMatch || !authorMatch) {
            console.log('Missing required fields');
            process.exit(1);
          }
          
          // Generate blog post JSON
          const blogPost = {
            id: `post-${Date.now()}`,
            title: titleMatch[1].trim(),
            excerpt: excerptMatch ? excerptMatch[1].trim() : '',
            content: contentMatch[1].trim(),
            author: authorMatch[1].trim(),
            publishedAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            readTime: Math.ceil(contentMatch[1].split(' ').length / 200) + ' min read',
            category: categoryMatch ? categoryMatch[1] : 'Beginner',
            tags: tagsMatch ? tagsMatch[1].split(',').map(tag => tag.trim()) : [],
            featured: false,
            seoTitle: seoTitleMatch ? seoTitleMatch[1].trim() : titleMatch[1].trim(),
            seoDescription: seoDescMatch ? seoDescMatch[1].trim() : (excerptMatch ? excerptMatch[1].trim() : ''),
            keywords: keywordsMatch ? keywordsMatch[1].split(',').map(kw => kw.trim()) : [],
            slug: slugMatch ? slugMatch[1].trim() : `post-${Date.now()}`,
            relatedPosts: [],
            seoMetadata: {
              title: (seoTitleMatch ? seoTitleMatch[1].trim() : titleMatch[1].trim()) + ' | Sayola',
              description: excerptMatch ? excerptMatch[1].trim().substring(0, 160) : '',
              keywords: keywordsMatch ? keywordsMatch[1].split(',').map(kw => kw.trim()) : []
            }
          };
          
          // Save to file
          const filename = `${blogPost.slug}.json`;
          fs.writeFileSync(filename, JSON.stringify(blogPost, null, 2));
          
          // Output filename for subsequent steps
          console.log(`FILENAME=${filename}`);
          
        } catch (error) {
          console.error('Error processing blog post:', error);
          process.exit(1);
        }
        EOF
        
        # Run extraction script
        ISSUE_BODY="${{ github.event.issue.body }}" node extract_blog.js > output.txt
        
        # Check if successful
        if [ $? -eq 0 ]; then
          filename=$(grep "FILENAME=" output.txt | cut -d'=' -f2)
          echo "filename=$filename" >> $GITHUB_OUTPUT
          echo "success=true" >> $GITHUB_OUTPUT
        else
          echo "success=false" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push blog post
      if: steps.extract.outputs.success == 'true'
      run: |
        # Configure Git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Move file to correct location
        mv "${{ steps.extract.outputs.filename }}" "content/blog/"
        
        # Commit changes
        git add "content/blog/${{ steps.extract.outputs.filename }}"
        git commit -m "Auto-publish blog post: ${{ steps.extract.outputs.filename }}"
        git push

    - name: Update issue with success status
      if: steps.extract.outputs.success == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: '‚úÖ **Blog post auto-published successfully!**\n\nThe article has been added to the website and will take effect on the next deployment.\n\nThank you for your contribution! üéâ'
          });
          
          // Add published label
          github.rest.issues.addLabels({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: ['published']
          });
          
          // Remove auto-publish label
          try {
            github.rest.issues.removeLabel({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'auto-publish'
            });
          } catch (error) {
            // Label might not exist, ignore error
          }

    - name: Update issue with failure status
      if: steps.extract.outputs.success == 'false'
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: '‚ùå **Auto-publish failed**\n\nPossible reasons:\n- Incorrect passcode\n- Missing required fields\n- Incorrect format\n\nPlease check your submission content and re-edit the Issue.'
          });