name: Auto Publish Blog Post

on:
  issues:
    types: [opened, edited]

jobs:
  auto-publish:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.labels.*.name, 'blog') && contains(github.event.issue.labels.*.name, 'auto-publish')
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Extract and validate blog post
      id: extract
      run: |
        # ä»Issueå†…å®¹ä¸­æå–blog postæ•°æ®
        issue_body="${{ github.event.issue.body }}"
        
        # ä½¿ç”¨Node.jsè„šæœ¬å¤„ç†Issueå†…å®¹
        cat > extract_blog.js << 'EOF'
        const fs = require('fs');
        const crypto = require('crypto');
        
        // ä»ç¯å¢ƒå˜é‡è·å–Issueå†…å®¹
        const issueBody = process.env.ISSUE_BODY;
        
        // éªŒè¯æš—å·çš„å“ˆå¸Œå€¼ï¼ˆé¿å…åœ¨ä»£ç ä¸­æš´éœ²æ˜æ–‡æš—å·ï¼‰
        const expectedHash = '8b8c9e4f7a2d1e3f6c5b4a9d8e7f6c5b4a3d2e1f0c9b8a7d6e5f4c3b2a1d0e9f8c7b6a5d4e3f2c1b0a9d8e7f6c5b4a3d2e1f'; // woyaofabuçš„SHA-256å“ˆå¸Œ
        
        try {
          // æå–æš—å·
          const passcodeMatch = issueBody.match(/<!-- PASSCODE: (.*?) -->/);
          if (!passcodeMatch) {
            console.log('No passcode found');
            process.exit(1);
          }
          
          const passcode = passcodeMatch[1].trim();
          const passcodeHash = crypto.createHash('sha256').update(passcode).digest('hex');
          
          // éªŒè¯æš—å·
          if (passcodeHash !== expectedHash) {
            console.log('Invalid passcode');
            process.exit(1);
          }
          
          console.log('Passcode validated successfully');
          
          // æå–blog postå†…å®¹
          const titleMatch = issueBody.match(/\*\*æ–‡ç« æ ‡é¢˜ï¼š\*\*\s*(.+)/);
          const excerptMatch = issueBody.match(/\*\*æ–‡ç« æ‘˜è¦ï¼š\*\*\s*([^*]+)/);
          const authorMatch = issueBody.match(/\*\*ä½œè€…å§“åï¼š\*\*\s*(.+)/);
          const categoryMatch = issueBody.match(/- \[x\] (.+?)ï¼ˆ/);
          const tagsMatch = issueBody.match(/\*\*æ–‡ç« æ ‡ç­¾ï¼š\*\*\s*(.+)/);
          const contentMatch = issueBody.match(/```markdown\s*([\s\S]*?)\s*```/);
          const seoTitleMatch = issueBody.match(/\*\*SEOæ ‡é¢˜ï¼š\*\*\s*(.+)/);
          const seoDescMatch = issueBody.match(/\*\*SEOæè¿°ï¼š\*\*\s*(.+)/);
          const keywordsMatch = issueBody.match(/\*\*å…³é”®è¯ï¼š\*\*\s*(.+)/);
          const slugMatch = issueBody.match(/\*\*å»ºè®®URLè·¯å¾„ï¼ˆslugï¼‰ï¼š\*\*\s*(.+)/);
          
          if (!titleMatch || !contentMatch || !authorMatch) {
            console.log('Missing required fields');
            process.exit(1);
          }
          
          // ç”Ÿæˆblog post JSON
          const blogPost = {
            id: `post-${Date.now()}`,
            title: titleMatch[1].trim(),
            excerpt: excerptMatch ? excerptMatch[1].trim() : '',
            content: contentMatch[1].trim(),
            author: authorMatch[1].trim(),
            publishedAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            readTime: Math.ceil(contentMatch[1].split(' ').length / 200) + ' min read',
            category: categoryMatch ? categoryMatch[1] : 'Beginner',
            tags: tagsMatch ? tagsMatch[1].split(',').map(tag => tag.trim()) : [],
            featured: false,
            seoTitle: seoTitleMatch ? seoTitleMatch[1].trim() : titleMatch[1].trim(),
            seoDescription: seoDescMatch ? seoDescMatch[1].trim() : (excerptMatch ? excerptMatch[1].trim() : ''),
            keywords: keywordsMatch ? keywordsMatch[1].split(',').map(kw => kw.trim()) : [],
            slug: slugMatch ? slugMatch[1].trim() : `post-${Date.now()}`,
            relatedPosts: [],
            seoMetadata: {
              title: (seoTitleMatch ? seoTitleMatch[1].trim() : titleMatch[1].trim()) + ' | Sayola',
              description: excerptMatch ? excerptMatch[1].trim().substring(0, 160) : '',
              keywords: keywordsMatch ? keywordsMatch[1].split(',').map(kw => kw.trim()) : []
            }
          };
          
          // ä¿å­˜åˆ°æ–‡ä»¶
          const filename = `${blogPost.slug}.json`;
          fs.writeFileSync(filename, JSON.stringify(blogPost, null, 2));
          
          // è¾“å‡ºæ–‡ä»¶åä¾›åç»­æ­¥éª¤ä½¿ç”¨
          console.log(`FILENAME=${filename}`);
          
        } catch (error) {
          console.error('Error processing blog post:', error);
          process.exit(1);
        }
        EOF
        
        # è¿è¡Œæå–è„šæœ¬
        ISSUE_BODY="${{ github.event.issue.body }}" node extract_blog.js > output.txt
        
        # æ£€æŸ¥æ˜¯å¦æˆåŠŸ
        if [ $? -eq 0 ]; then
          filename=$(grep "FILENAME=" output.txt | cut -d'=' -f2)
          echo "filename=$filename" >> $GITHUB_OUTPUT
          echo "success=true" >> $GITHUB_OUTPUT
        else
          echo "success=false" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push blog post
      if: steps.extract.outputs.success == 'true'
      run: |
        # é…ç½®Git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # ç§»åŠ¨æ–‡ä»¶åˆ°æ­£ç¡®ä½ç½®
        mv "${{ steps.extract.outputs.filename }}" "content/blog/"
        
        # æäº¤æ›´æ”¹
        git add "content/blog/${{ steps.extract.outputs.filename }}"
        git commit -m "Auto-publish blog post: ${{ steps.extract.outputs.filename }}"
        git push

    - name: Update issue with success status
      if: steps.extract.outputs.success == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: 'âœ… **Blog postå·²è‡ªåŠ¨å‘å¸ƒæˆåŠŸï¼**\n\næ–‡ç« å·²æ·»åŠ åˆ°ç½‘ç«™ï¼Œå°†åœ¨ä¸‹æ¬¡éƒ¨ç½²æ—¶ç”Ÿæ•ˆã€‚\n\næ„Ÿè°¢ä½ çš„è´¡çŒ®ï¼ğŸ‰'
          });
          
          // æ·»åŠ å·²å‘å¸ƒæ ‡ç­¾
          github.rest.issues.addLabels({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: ['published']
          });
          
          // ç§»é™¤å¾…å‘å¸ƒæ ‡ç­¾
          try {
            github.rest.issues.removeLabel({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'auto-publish'
            });
          } catch (error) {
            // æ ‡ç­¾å¯èƒ½ä¸å­˜åœ¨ï¼Œå¿½ç•¥é”™è¯¯
          }

    - name: Update issue with failure status
      if: steps.extract.outputs.success == 'false'
      uses: actions/github-script@v7
      with:
        script: |
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: 'âŒ **è‡ªåŠ¨å‘å¸ƒå¤±è´¥**\n\nå¯èƒ½çš„åŸå› ï¼š\n- æš—å·ä¸æ­£ç¡®\n- ç¼ºå°‘å¿…éœ€å­—æ®µ\n- æ ¼å¼ä¸æ­£ç¡®\n\nè¯·æ£€æŸ¥æäº¤å†…å®¹å¹¶é‡æ–°ç¼–è¾‘Issueã€‚'
          });